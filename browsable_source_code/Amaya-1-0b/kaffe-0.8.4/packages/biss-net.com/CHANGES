================================== 0.87 ======================================

Bugs
-------

Awt.<clinit>: ScreenSize used before initialized (X/YResolution)

Parser bug: multiple field inits in same line (e.g. "int a=0, b=1;")

TextField compatibility: <Cr> triggers ACTION event

GifProducer problem: end of gif file not detected (nextCode() -> CodeEOF)

several Dialog layout offset specs: StringPrompter buttons etc.

Designer overwrites existing target class ctor

"initStdColors" problem (PseudoColor visual startup problem on several
old X servers)

environment var TARGET now can be used to set platform specific compiler or
linker options for building the native lib (e.g. "linux", "bsd"). Please let
us now if you want/need additional platforms / settings

TextArea compatibility appendText (wrong insert pos returned by
TextAreaCanvas.posOf, appendText added to TextArea)

TextArea colorize problem (caused by standard
java.awt.Graphics.drawChars() implementation, can be seen in
Awt.<clInit> lines with embedded tabs)

TextArea cut problem at end of line (causing already deleted text to
reappear) because of forgotten Selection reset

biss.awt.kernel.Graphics drawChars() buffer overrun

wrong state set in biss.awt.kernel.Image by Toolkit.produceImage()
(has to check for ongoing production first)

PaneDrawer threads are now stopped when closing the owner toplevel window
(LibBrowserm, CUBrowser, this avoids getting BadDrawable errors for already
closed windows)

biss.awt.kernel.Graphics does not shut down app on non-severe X errors
(e.g. BadDrawable)

pointer reset workaround (does not get reset properly when
re-entering a container from a child window, this is actually a JDK
problem of MOUSE_ENTER / MOUSE_EXIT events not dispatched properly to
Container instances)

some minor biss.awt.List bugs ( List(String), ListCanvas.mouse1Up(), ..)

various other small bugfixes (graphics.c ...)

added translate() support for biss.awt.kernel.Graphics (and graphics.c)

Windows JDK NoteBook bug workaround (page not changed on first mouse
click on tab). This is caused by wrong Event.x / Event.y coordinates
(set by the JDK) in the MOUSE_DOWN event

Decoration blank() fixed (now just redraws what was obscured by the
Decoration subclass)

biss.awt.kernel by default now shrinks Frame sizes by an amount which
should equal WindowManager decorations

biss.awt.GifProducer now silently accepts truncated GIF raster data (i.e.
incomplete images) because the JDK does not complain about them

biss.awt.kernel.Graphics.drawImage(image,x,y,observer) now uses the
window backcolor for transparent GIF images (formerly, it had to be
requested explicitly by specifying a backcolor in the drawImage()
call). The GIF background pixel value is no longer used as 
transparent color.

Decorations are now drawn correctly if becoming visible via the
Layouter.setLayout() (i.e. during a layout switch). Because Decorations
don't have peers, the isShowing() had to be re-implemented to catch
the initially invisible state.

The old OS/2 hotkey workaround (for alt keys) is no longer required and
has been removed. OS/2 hotkeys are working now

TextArea scrollHorizontal had a wrong x offset when scrolling back to
the left (right scroll -> left scroll with mouse cause garbage at the
left edge of the TextArea)

Fix for Windows mouse handling which sometimes sends mouse events not
just to the terminal widget but also to its frame (e.g. mouse move after
a setting a layout)

Windows and OS/2 "focus switch" MOUSE_DRAG avant filtered out (when
getting the focus, a single drag event is send during the mouse down
and mouse up which caused the TextArea to loose again - because of its
drag processing - the selection)

Premature  sudden death of PaneDrawer threads (terminating on !isShowing() )
has been fixed (safety stop is now based on getPeer())

native lib workaround for toplevel initial focus problems with fvwm95
(toplevel sometimes don't get the focus if not explicitly requested
during ReparentNotify). This caused the prior toplevel to float on top
again after the new one was mapped

Layouter rounding error fixed (causing the right edge of components not to
be aligned properly, was apparent in the biss.jde.CUViewer Method- and
TextPane)

Operations on explicitly (by createGraphics()) requested Graphics objects
are now checked for failed createGraphics calls (null checked). This became
especially apparent in Windows after (temporarily) hiding components during
a layoutContainer().


Other changes
-------------

biss.awt.kernel font mapping parameterized (can be set in biss.awt)

X display name can be set via
 - package property "biss.awt.kernel.Display"   -or if not set-
 - system property "display"                    -or if not set-
 - DISPLAY environment variable

64-bit porting easements ("int pData" -> "long PData")

biss.awt.kernel native popup support (Pointer grab, has to be activated via
property file "biss.awt.kernel.NativePopUps=true")

SingleInstWnd (PopUp, Choice) closed when activating a non-Java
toplevel window

biss.awt widgets used as peers now have the same font & color defaults
like non-peers

openNotify(), closeNotify() removed in biss.awt.Control derived
classes (resident graphics initialization moved to paint())

per CompileUnit "Format" menu item added to CUBrowser (File->Format)

pretty printing "Print" menu item added to CUBrowser (File->Print)

"//" comments in *.c files replaced with "/*..*/" (for BSD compatibility)

paint() filtering (for AWT implementations / X servers not using
backing store, partially obscured windows can lead to endless series
of paints). This is controlled by the integer package property
'biss.awt.FilterPaints', if it is set to a value > 0 (in ms), successive
paints within the specified amount of time are queued and deferred
(unique, i.e. not accumulative) via the CommandQueue. If it is set to 0,
no filtering is performed.

java.awt.image.IndexColorModels can now be rendered by
biss.awt.kernel.Images

biss.awt.GraphicsLib widget draw support streamlined (there where lots of
non-orthogonal or even unused methods)

ImageEditor now imports Gif files

Popup sub-menus are now opened only on demand (by mouse click or Enter
key). Some window managers got confused about very fast open/close
cycles when moving the mouse across a popup menu.

paint() / redraw() streamlined. paint() now draws everything
(including borders), redraw() is used (mostly sync, i.e. explicitly
called) just to redraw contents.  As a consequence, redrawWithBorders() has
been removed

Border drawing is now performed strictly by the owner of a border. The
old ScrollablePane / ScrollableCanvas anomaly (the pane drawing its
border around the canvas) has been eliminated. ScrollableCanvases now
could have all sorts of borders

Text replace dialog added to the standard biss.awt.TextArea

Vertical soft scroll mode  added to Lists and TextAreas. Can be switched
off (for slow X servers or low memory) by setting the package property
'biss.awt.SoftScroll=false'. If it is activated, mouse button 2 clicks
on the (vertical) Scrollbar buttons should result in a soft scroll. If the
scroll op is too fast or jerky (due to interruptive thread rescheduling),
you can increase the "SoftScrollDelay" property (which is approximately
the number of milliseconds a single 100 ms scan line scroll op should be
deferred). If a single scan line scroll took more than 400 ms, there is
no delay at all (between 100 and 400 ms, the amount is computed
proportionally).
However, soft scrolling depends on a steady movement which is not easy
to achieve without explicit knowledge of the threading mechanism of the VM.
The current implementation is a compromise, i.e. there might be the need for
more target specific scrolling policies.

Layouter & reshape() repainting streamlined. When resizing a layout,
the Layouter now first hides all components. When switching a layout
(e.g. zooming), the Layouter hides all components with different specs
before reshaping anything. There is no more sync drawing done in
reimplemented reshape() methods. This was changed because sync
painting sometimes produces extra redraws / screen flicker (when sync
painting reshaped but still obscured components). There also where
some nasty code sequences in Component and Control (dealing with sync
repaint) which have been eliminated.

popups are now disposed before executing any commands in response to user
selections to prevent WM focus errors with toplevels brought up during
popup triggered commands (which might occur when the toplevel tries to
restore the focus to its owner)

TextArea selection are now focs persistent (i.e. loosing the focus does
not reset thee selection). This is more robust with transients which cause
selections (like the Find dialog). It also does not make sense to perform
some extra actions (like redrawing the selection and blanking the cursor)
just to loose some information. If the user does a mouse click in a
non-focused TextArea which has a selection, the widget gets the focus
but does not change the cursor position. If there was no selection, the
cursor is set according to the mouse position. If the TextArea already
had the focus, the selection (if any) is reset and the cursor is changed.
Visible persistent selections also will be the basis for the upcoming diff
display

We now enforce order and exclusiveness of getFocus() / lostFocus() / mouseEnter()
notification calls. The GUIHandler keeps track of the current focus handler,
the last focus handler and the current mouse handler (in static fields). This
became necessary because FOCUS AND MOUSE EVENT HANDLING IS THE MOST SERIOUS
SOURCE OF PROBLEMS FOR PLATFORM DEPENDENT AWT INCOMPATIBILITIES. IF YOUR PROGRAM
IS REQUIRED TO RUN ON SEVERAL PLATFORMS, TAKE THIS ADVICE: NEVER RELY ON A SPECIFIC
NUMBER AND ORDER OF FOCUS / MOUSE EVENTS. However, with biss-awt you at least can
rely on consistent lostFocus() / gotFocus() pairs, mouseExit() before mouseEnter(),
and the exclusiveness of the CurrentFocusHandler / LastFocusHandler /
CurrentMouseHandler

The TopWindow now keeps track of the last focused child and, if it directly
gets notified by gotFocus(), tries to restore the focus accordingly

There now is a SetFocusCmd which can be used (via the CommandQueue) like
ToFrontCmd objects to try harder to set the focus (requestFocus() might be
sometimes ignored or overridden by the window manager). As a consequence,
native lib set focus enforcement (for not yet exposed windows) has been
removed (it solved  just a special case of the above task)

The "look" of many specific widgets (Buttons, SpinButtons, Choices, Checkboxes,
Borders) has been centralized in the biss.awt.GraphicsLib class (paintButton(),
paintChoiceButton() etc.). If you don't like the current look (some people really
think every GUI has to look like Windooze), you just have to replace these
methods with your own version (and you should not bother us again with
Windooze non-conformance :)

The TextField now shows a small marker in its upper right edge everytime its
contents have been validated by the user (e.g. by hitting the Enter key). This
makes it easier to keep track of operations in apps which trigger a lot of
functions by validating TextField contents.


Interface modifications
-----------------------

biss.CommandQueue.addCommand() -> append() (biss.Queue conforming)

TopWindow.addOverlay() -> setOverlay() (only a single overlay per
toplevel allowed because automatic z-order control is not very
reliable without window manager cooperation)

property 'biss.awt.ScreenSize' now specified in 1/10 '' (required to fine tune
postscript print scaling)

property 'biss.awt.CorsorColor' renamed to 'CursorClr' (consistency)

biss.awt.kernel by default now shrinks Frame extends by (assumed)
WindowManager border decorations. Can be fine-tuned by the package
properties 'biss.awt.kernel.TitleInset' and
'biss.awt.kernel.BorderInset'. If the first one is not set explicitly,
it is computed from the biss.awt.SysFontHeight setting (3/2).  If you
don't like this at all, switch Frame shrinking off by setting the
package property 'biss.awt.kernel.ShrinkFrame=false'

TextArea selections not reset when loosing/getting the focus (see above)

Consistency of lostFocus() / gotFocus(), mouseExit() / mouseEnter() /
mouseMove() notifications may break some platform specific workaround hacks
(see above)


