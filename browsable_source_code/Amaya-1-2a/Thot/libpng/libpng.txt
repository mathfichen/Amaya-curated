libpng.txt - a description on how to use and modify libpng

    libpng 1.0 beta 2 - version 0.87
    For conditions of distribution and use, see copyright notice in png.h
    Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
    January 15, 1996
    Updated/rewritten per request in the libpng FAQ
    Copyright (c) 1995 Frank J. T. Wojcik
    December 18, 1995 && January 20, 1996

I. Introduction

This file describes how to use and modify the PNG reference library
(known as libpng) for your own use.  There are five sections to this
file: introduction, structures, reading, writing, and modification and
configuration notes for various special platforms.  In addition to this
file, example.c is a good starting point for using the library, as
it is heavily commented and should include everything most people
will need.

Libpng was written as a companion to the PNG specification, as a way
to reduce the amount of time and effort it takes to support the PNG
file format in application programs.  Most users will not have to
modify the library significantly; advanced users may want to modify it
more.  All attempts were made to make it as complete as possible,
while keeping the code easy to understand.  Currently, this library
only supports C.  Support for other languages is being considered.

Libpng has been designed to handle multiple sessions at one time,
to be easily modifiable, to be portable to the vast majority of
machines (ANSI, K&R, 16 bit, 32 bit) available, and to be easy to
use.  The ultimate goal of libpng is to promote the acceptance of
the PNG file format in whatever way possible.  While there is still
work to be done (see the pngtodo.txt file), libpng should cover the
majority of the needs of it's users.

Libpng uses zlib for its compression and decompression of PNG files.
The zlib compression utility is a general purpose utility that is
useful for more than PNG files, and can be used without libpng.
See the documentation delivered with zlib for more details.

Libpng is thread safe, provided the threads are using different
instances of the structures.  Each thread should have its own
png_struct and png_info instances, and thus its own image.
Libpng does not protect itself against two threads using the
same instance of a structure.



II. Structures

There are two main structures that are important to libpng, png_struct
and png_info.  The first, png_struct, is an internal structure that
will not, for the most part, be used by the general user except as
the first variable passed to every png function call.

The png_info structure is designed to provide information about the
png file.  All of its fields are intended to be examined or modified
by the user.  See png.h for a good description of the png_info fields.
png.h is also an invaluable reference for programming with libpng.

And while I'm on the topic, make sure you include the png header file:

#include <png.h>



III. Reading

Reading PNG files:

We'll now walk you through the possible functions to call when reading
in a PNG file, briefly explaining the syntax and purpose of each one.
See example.c and png.h for more detail.  While Progressive reading
is covered in the next section, you will still need some of the
functions discussed in this section to read a PNG file.

You will want to do the I/O initialization(*) before you get into libpng,
so if it doesn't work, you don't have much to undo.  Of course, you
will also want to insure that you are, in fact, dealing with a PNG
file.  Libpng provides a simple check to see if a file is a PNG file.
To use it, pass in the first 1 to 8 bytes of the file, and it will
return true or false (1 or 0) depending on whether the bytes could be
part of a PNG file.  Of course, the more bytes you pass in, the
greater the accuracy of the prediction.  If you pass in more then
eight bytes, libpng will only look at the first eight bytes.

(*): If you are not using the standard I/O functions, you will need
to replace them with custom functions.  See the discussion under
Customizing libpng.

    FILE *fp = fopen(file_name, "rb");
    if (!fp)
    {
        return;
    }
    fread(header, 1, number, fp);
    is_png = png_check_sig(header, number);
    if (!is_png)
    {
        return;
    }

Next, png_struct and png_info need to be allocated and initialized.
As these are both large, you may not want to store these on the stack,
unless you have stack space to spare.  Of course, you will want to
check if malloc returns NULL.

    png_structp png_ptr = malloc(sizeof (png_struct));
    if (!png_ptr)
        return;
    png_infop info_ptr = malloc(sizeof (png_info));
    if (!info_ptr)
    {
        free(png_ptr);
        return;
    }

After you have these structures, you will need to set up the
error handling.  When libpng encounters an error, it expects to
longjmp back to your routine.  Therefore, you will need to call
setjmp and pass the jmpbuf field of your png_struct.  If you
read the file from different routines, you will need to update
the jmpbuf field every time you enter a new routine that will
call a png_ function.  See your documentation of setjmp/longjmp
for your compiler for more information on setjmp/longjmp.  See
the discussion on libpng error handling in the Customizing Libpng
section below for more information on the libpng error handling.
If an error occurs, and libpng longjmp's back to your setjmp,
you will want to call png_read_destroy() to free any memory.

    if (setjmp(png_ptr->jmpbuf))
    {
        png_read_destroy(png_ptr, info_ptr, (png_info *)0);
        /* free pointers before returning, if necessary */
        free(png_ptr);
        free(info_ptr);
        fclose(fp);
        return;
    }

Next, you will need to call png_info_init() and png_read_init().
These functions make sure all the fields are initialized to useful
values, and, in the case of png_read_init(), and allocate any memory
needed for internal uses.  You must call png_info_init() first, as
png_read_init() could do a longjmp, and, if the info is not initialized,
then png_read_destroy() could try to png_free() random addresses, which
would be bad.

    png_info_init(info_ptr);
    png_read_init(png_ptr);

Now you need to set up the input code.  The default for libpng is to
use the C function fread().  If you use this, you will need to pass a
valid FILE * in the function png_init_io().  Be sure that the file is
opened in binary mode.  Again, if you wish to handle reading data in
another way, see the discussion on libpng I/O handling in the Customizing
Libpng section below.

    png_init_io(png_ptr, fp);

You are now ready to read all the file information up to the actual
image data.  You do this with a call to png_read_info().

   png_read_info(png_ptr, info_ptr);

The png_info structure is now filled in with all the data necessary
to read the file.  Some of the more important parts of the png_info are:

    width          - holds the width of the file
    height         - holds the height of the file
    bit_depth      - holds the bit depth of one of the image channels
    color_type     - describes the channels and what they mean
                     (see the PNG_COLOR_TYPE_ macros for more information)
    channels       - number of channels of info for the color type
    pixel_depth    - bits per pixel, the result of multiplying the 
                     bit_depth times the channels
    rowbytes       - number of bytes needed to hold a row
    interlace_type - currently 0 for none, 1 for interlaced
    valid          - this details which optional chunks were found in the
                     file to see if a chunk was present, AND valid with
                     the appropriate PNG_INFO_<chunk name> define.

These are also important, but their validity depends on whether a
corresponding chunk exists. Use valid (see above) to ensure that what
you're doing with these values makes sense.

    palette        - the palette for the file
    num_palette    - number of entries in the palette
    gamma          - the gamma the file is written at
    sig_bit        - the number of significant bits
                     for the gray, red, green, and blue channels, whichever
                     are appropriate for the given color type.
    trans_values   - transparent pixel for non-paletted images
    trans          - array of transparent entries for paletted images
    num_trans      - number of transparent entries
    hist           - histogram of palette
    text           - text comments in the file.
    num_text       - number of comments

for more information, see the png_info definition in png.h and the
PNG specification for chunk contents.  Be careful with trusting
rowbytes, as some of the transformations could increase the space
needed to hold a row (expand, rgbx, xrgb, graph_to_rgb, etc.).
See png_update_info(), below.

A quick word about text and num_text.  PNG stores comments in
keyword/text pairs, one pair per chunk.  While there are suggested
keywords, there is no requirement to restrict the use to these
strings.  There is a requirement to have at least one character for a
keyword.  It is strongly suggested that keywords be sensible to humans
(that's the point), so don't use abbreviations.  See the png
specification for more details.  There is also no requirement to have
text after the keyword.

Keywords are restricted to 80 characters without leading or trailing
spaces, but spaces are allowed within the keyword  It is possible to
have the same keyword any number of times.  The text field is an
array of png_text structures, each holding pointer to a keyword
and a pointer to a text string.  Only the text string may be null.
The keyword/text pairs are put into the array in the order that
they are received.  However, some or all of the text chunks may be
after the image, so, to make sure you have read all the text chunks,
don't mess with these until after you read the stuff after the image.
This will be mentioned again below in the discussion that goes with
png_read_end().

After you've read the file information, you can set up the library to
handle any special transformations of the image data.  The various
ways to transform the data will be described in the order that they
should occur.  This is important, as some of these change the color
type and/or bit depth of the data, and some others only work on
certain color types and bit depths.  Even though each transformation
checks to see if it has data that it can do somthing with, you should
make sure to only enable a transformation if it will be valid for the
data.  For example, don't swap red and blue on grayscale data.

The following code transforms bit depths of less than 8 to 8 bits,
changes paletted images to rgb, and adds an alpha channel if there is
transparency information in a tRNS chunk.  This is probably most
useful on grayscale images with bit depths of 2 or 4 and tRNS chunks.

   if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&
      info_ptr->bit_depth < 8)
        png_set_expand(png_ptr);

    if (info_ptr->color_type == PNG_COLOR_TYPE_GRAY &&
      info_ptr->bit_depth < 8)
      png_set_expand(png_ptr);

   if (info_ptr->valid & PNG_INFO_tRNS)
      png_set_expand(png_ptr);

The following code handles alpha and transparency by replacing it with
a background value.  If there was a valid one in the file, you can use
it if you want.  However, you can replace it with your own if you want
also.  If there wasn't one in the file, you must supply a color.  If
libpng is doing gamma correction, you will need to tell libpng where
the background came from so it can do the appropriate gamma
correction.  If you are telling libpong to modify the color data with
png_set_expand(), you must indicate whether the background needs to be
expanded.  See the function definition in png.h for more details.

    png_color_16 my_background;

   if (info_ptr->valid & PNG_INFO_bKGD)
      png_set_backgrond(png_ptr, &(info_ptr->background),
            PNG_BACKGROUND_GAMMA_FILE, 1, 1.0);
   else
      png_set_background(png_ptr, &my_background,
         PNG_BACKGROUND_GAMMA_SCREEN, 0, 1.0);

The following code handles gamma transformations of the data.  Pass
both the file gamma and the desired screen gamma.  If the file does
not have a gamma value, you can pass one anyway if you wish.  Note
that file gammas are inverted from screen gammas.  See the discussions
on gamma in the PNG specification for more information.  It is
strongly recommended that viewers support gamma correction.

   if (info_ptr->valid & PNG_INFO_gAMA)
      png_set_gamma(png_ptr, screen_gamma, info_ptr->gamma);
    else
        png_set_gamma(png_ptr, screen_gamma, 0.45);

PNG can have files with 16 bits per channel.  If you only can handle
8 bits per channel, this will strip the pixels down to 8 bit.

   if (info_ptr->bit_depth == 16)
      png_set_strip_16(png_ptr);

If you need to reduce an rgb file to a paletted file, or if a paletted
file has more entries then will fit on your screen, png_set_dither()
will do that.  Note that this is a simple match dither that merely
finds the closest color available.  This should work fairly well with
optimized palettes, and fairly badly with linear color cubes.  If you
pass a palette that is larger then maximum_colors, the file will
reduce the number of colors in the palette so it will fit into
maximum_colors.  If there is a histogram, it will use it to make
intelligent choices when reducing the palette.  If there is no
histogram, it may not do as good a job.

It should be noted that this function will be rewritten and/or
replaced in libpng 0.9, which will have full two pass dithering with
optimized palettes.

   if (info_ptr->color_type & PNG_COLOR_MASK_COLOR)
   {
      if (info_ptr->valid & PNG_INFO_PLTE)
      {
         png_set_dither(png_ptr, info_ptr->palette,
            info_ptr->num_palette, max_screen_colors,
            info_ptr->histogram, 1);
      }
      else
      {
         png_color std_color_cube[MAX_SCREEN_COLORS] =
            { ... colors ... };

         png_set_dither(png_ptr, std_color_cube, MAX_SCREEN_COLORS,
            MAX_SCREEN_COLORS, NULL,0);
      }
   }

PNG files describe monochrome as black being zero and white being one.
The following code will reverse this (make black be one and white be
zero):

   if (info_ptr->bit_depth == 1 &&
      info_ptr->color_type == PNG_COLOR_GRAY)
      png_set_invert_mono(png_ptr);

PNG files have possible bit depths of 1, 2, 4, 8, and 16.  However,
they also provide a way to describe the true bit depth of the image.
It is then required that values be "scaled" or "shifted" up to the bit
depth used in the file.  See the PNG specification for details.  This
code reduces the pixels back down to the true bit depth:

    if (info_ptr->valid & PNG_INFO_sBIT)
        png_set_shift(png_ptr, &(info_ptr->sig_bit));

PNG files pack pixels of bit depths 1, 2, and 4 into bytes as small as
they can, resulting in, for example, 8 pixels per byte for 1 bit
files.  This code expands to 1 pixel per byte without changing the
values of the pixels:

    if (info_ptr->bit_depth < 8)
        png_set_packing(png_ptr);

PNG files store 3 color pixels in red, green, blue order.  This code
changes the storage of the pixels to blue, green, red:

    if (info_ptr->color_type == PNG_COLOR_TYPE_RGB ||
        info_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
        png_set_bgr(png_ptr);

For some uses, you may want a gray-scale image to be represented as
rgb.  This code will do that conversion:

   if (info_ptr->color_type == PNG_COLOR_TYPE_GRAY ||
      info_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
         png_set_gray_to_rgb(png_ptr);

PNG files store 16 bit pixels in network byte order (big-endian,
ie. most significant bits first).  This code chages the storage to the
other way (little-endian, ie. least significant bits first, eg. the
way PCs store them):

    if (info_ptr->bit_depth == 16)
        png_set_swap(png_ptr);

PNG files store rgb pixels packed into 3 bytes. This code packs them
into 4 bytes:

   if (info_ptr->bit_depth == 8 &&
      info_ptr->color_type == PNG_COLOR_TYPE_RGB)
      png_set_filler(png_ptr, filler_byte, PNG_FILLER_BEFORE);

where filler_byte is the number to fill with, and the location is
either PNG_FILLER_BEFORE or PNG_FILLER_AFTER, depending upon whether
you want the filler before the rgb or after.

The last thing to handle is interlacing; this is covered in detail below,
but you must call the function here.

   if (info_ptr->interlace_type)
      number_passes = png_set_interlace_handling(png_ptr);

After setting the transformations, you can update your palette by
calling png_start_read_image().  This function is provided for those
who need an updated palette before they read the image data.  If you
don't call this function, the library will automatically call it
before it reads the first row.

    png_start_read_image(png_ptr);

libpng can update your png_info structure to reflect any
transformations you've requested with this call.  This is most useful
to update the info structures rowbytes field, so you can use it to
allocate your image memory.  This function calls
png_start_read_image(), so you don't have to call both of them.

    png_read_update_info(png_ptr, info_ptr);

After you call png_read_update_info(), you can allocate any
memory you need to hold the image.  As the actual allocation
varies among applications, no example will be given.  If you
are allocating one large chunk, you may find it useful to
build an array of pointers to each row, as it will be needed
for some of the functions below.

After you've allocated memory, you can read the image data.
The simplest way to do this is in one function call.  If you are
allocating enough memory to hold the whole image, you can just
call png_read_image() and libpng will read in all the image data
and put it in the memory area supplied.  You will need to pass in
an array of pointers to each row.

This function automatically handles interlacing, so you don't need
to call png_set_interlace_handling() or call this function multiple
times, or any of that other stuff necessary with png_read_rows().

   png_read_image(png_ptr, row_pointers);

where row_pointers is:

    png_bytep row_pointers[height];

You can point to void or char or whatever you use for pixels.

If you don't want to read int the whole image at once, you can
use png_read_rows() instead.  If there is no interlacing (check
info_ptr->interlace_type), this is simple:

    png_read_rows(png_ptr, row_pointers, NULL, number_of_rows);

where row_pointers is the same as in the png_read_image() call.

If you are doing this just one row at a time, you can do this with
row_pointers:

    png_bytep row_pointers = row;
    png_read_rows(png_ptr, &row_pointers, NULL, 1);

If the file is interlaced (info_ptr->interlace_type != 0), things get
a good deal harder.  The only currently (as of 1/96 -- PNG
Specification version 0.92) defined interlacing scheme for PNG files
(info_ptr->interlace_type == 1) is a complicated interlace scheme,
known as Adam7, that breaks down an image into seven smaller images of
varying size.  libpng will fill out those images or it will give them
to you "as is".  If you want them filled out, there are two ways to
do that.  The one mentioned in the PNG specification is to expand each
pixel to cover those pixels that have not been read yet.  This results
in a blocky image for the first pass, which gradually smoothes out as
more pixels are read.  The other method is the "sparkle" method, where
pixels are draw only in their final locations, with the rest of the
image remaining whatever colors they were initialized to before the
start of the read.  The first method usually looks better, but tends
to be slower, as there are more pixels to put in the rows.

If you don't want libpng to handle the interlacing details, just
call png_read_rows() the correct number of times to read in all
seven images.  See the PNG specification for more details on the
interlacing scheme.

If you want libpng to expand the images, call this before calling
png_start_read_image() or png_read_update_info():

    if (info_ptr->interlace_type)
        number_passes = png_set_interlace_handling(png_ptr);

This will return the number of passes needed.  Currently, this
is seven, but may change if another interlace type is added.
This function can be called even if the file is not interlaced,
when it will return one.

If you are not going to display the image after each pass, but are
going to wait until the entire image is read in, use the sparkle
effect.  This effect is faster and the end result of either method
is exactly the same.  If you are planning on displaying the image
after each pass, the rectangle effect is generally considered the
better looking one.

If you only want the "sparkle" effect, just call png_read_rows() as
normal, with the third parameter NULL.  Make sure you make pass over
the image number_passes times, and you don't change the data in the
rows between calls.  You can change the locations of the data, just
not the data.  Each pass only writes the pixels appropriate for that
pass, and assumes the data from previous passes is still valid.

    png_read_rows(png_ptr, row_pointers, NULL, number_of_rows);

If you only want the first effect (the rectangles), do the same as
before except pass the row buffer in the third parameter, and leave
the second parameter NULL.

    png_read_rows(png_ptr, NULL, row_pointers, number_of_rows);

After you are finished reading the image, you can finish reading
the file.  If you are interested in comments or time, you should
pass the png_info pointer from the png_read_info() call.  If you
are not interested, you can pass NULL.

   png_read_end(png_ptr, info_ptr);

When you are done, you can free all memory used by libpng like this:

   png_read_destroy(png_ptr, info_ptr, (png_info *)0);

After that, you can discard the structures, or reuse them another
read or write.  For a more compact example of reading a PNG image,
see the file example.c.


Reading PNG files progressively:

The progressive reader is slightly different then the non-progressive
reader.  Instead of calling png_read_info(), png_read_rows(), and
png_read_end(), you make one call to png_process_data(), which calls
callbacks when it has the info, a row, or the end of the image.  You
set up these callbacks with png_set_progressive_read_fn().  You don't
have to worry about the input/output functions of libpng, as you are
giving the library the data directly in png_process_data().  I will
assume that you have read the section on reading PNG files above,
so I will only highlight the differences (although I will show
all of the code).

png_structp png_ptr;
png_infop info_ptr;

int
initialize_png_reader()
{
    png_ptr = malloc(sizeof (png_struct));
    if (!png_ptr)
        return -1;
    info_ptr = malloc(sizeof (png_info));
    if (!info_ptr)
    {
        free(png_ptr);
        return -1;
    }

    if (setjmp(png_ptr->jmpbuf))
    {
        png_read_destroy(png_ptr, info_ptr, (png_info *)0);
        /* free pointers before returning, if necessary */
        free(png_ptr);
        free(info_ptr);
        return -1;
    }

    png_info_init(info_ptr);
    png_read_init(png_ptr);

    /*
        This one's new.  You will need to provide all three
        function callbacks, even if you aren't using them all.
        You can use any void pointer as the user_ptr, and
        retrieve the pointer from inside the callbacks using
        the function png_get_progressive_ptr(png_ptr);        
    */
     png_set_progressive_read_fn(png_ptr, user_ptr,
        info_callback, row_callback, end_callback);

    return 0;
}

int
process_data(png_bytep buffer, png_uint_32 length)
{
    if (setjmp(png_ptr->jmpbuf))
    {
        png_read_destroy(png_ptr, info_ptr, (png_info *)0);
        free(png_ptr);
        free(info_ptr);
        return -1;
    }

    /* 
        This one's new also.  Simply give it a chunk of data
        from the file stream (in order, of course).  On machines
        with segmented memory models machines, don't give it any 
        more than 64K.  The library seems to run fine with sizes 
        of 4K. Although you can give it much less if necessary 
        (I assume you can give it chunks of 1 byte, I haven't
        tried less then 256 bytes yet).  When this function returns,
        you may want to display any rows that were generated in the
        row callback. 
    */
    png_process_data(png_ptr, info_ptr, buffer, length);
    return 0;
}

info_callback(png_structp png_ptr, png_infop info)
{
    /*
        Do any setup here, including setting any of the transformations
        mentioned in the Reading PNG files section.  For now, you _must_
        call either png_start_read_image() or png_read_update_info()
        after all the transformations are set (even if you don't set
        any).  You may start getting rows before png_process_data()
        returns, so this is your last chance to prepare for that.
    */
}

row_callback(png_structp png_ptr, png_bytep new_row,
    png_uint_32 row_num, int pass)
{
    /* 
        This function is called for every row in the image.  If the
        image is interlaced, and you turned on the interlace handler,
        this function will be called for every row in every pass.
        Some of these rows will not be changed from the previous pass.
        When the row is not changed, the new_row variable will be NULL.
        The rows and passes are called in order, so you don't really
        need the row_num and pass, but I'm supplying them because it
        may make your life easier.

        For the non-NULL rows of interlaced images, you must call
        png_progressive_combine_row() passing in the row and the
        old row.  You can call this function for NULL rows (it will
        just return) and for non-interlaced images (it just does the
        memcpy for you) if it will make the code easier.  Thus, you
        can just do this for all cases:

        png_progressive_combine_row(png_ptr, old_row, new_row);

        where old_row is what was displayed for previous rows.  Note
        that the first pass (pass == 0, really) will completely cover
        the old row, so the rows do not have to be initialized.  After
        the first pass (and only for interlaced images), you will have
        to pass the current row, and the function will combine the
        old row and the new row.
    */  
}

end_callback(png_structp png_ptr, png_infop info)
{
    /*  
        This function is called after the whole image has been read,
        including any chunks after the image (up to and including
        the IEND).  You will usually have the same info chunk as you
        had in the header, although some data may have been added
        to the comments and time fields.

        Most people won't do much here, perhaps setting a flag that
        marks the image as finished.
    */
}



IV. Writing

Much of this is very similar to reading.  However, everything of
importance is repeated here, so you won't have to constantly look
back up in the reading section to understand writing.

You will want to do the I/O initialization before you get into libpng,
so if it doesn't work, you don't have much to undo. If you are not
using the standard I/O functions, you will need to replace them with
custom functions.  See the discussion under Customizing libpng.
    
    FILE *fp = fopen(file_name, "wb");
    if (!fp)
    {
        return;
    }

Next, png_struct and png_info need to be allocated and initialized.
As these are both large, you may not want to store these on the stack,
unless you have stack space to spare.  Of course, you will want to
check if malloc returns NULL.

    png_structp png_ptr = malloc(sizeof (png_struct));
    if (!png_ptr)
        return;
    png_infop info_ptr = malloc(sizeof (png_info));
    if (!info_ptr)
    {
        free(png_ptr);
        return;
    }

After you have these structures, you will need to set up the
error handling.  When libpng encounters an error, it expects to
longjmp back to your routine.  Therefore, you will need to call
setjmp and pass the jmpbuf field of your png_struct.  If you
write the file from different routines, you will need to update
the jmpbuf field every time you enter a new routine that will
call a png_ function.  See your documentation of setjmp/longjmp
for your compiler for more information on setjmp/longjmp.  See
the discussion on libpng error handling in the Customizing Libpng
section below for more information on the libpng error handling.
    
    if (setjmp(png_ptr->jmpbuf))
    {    
        png_write_destroy(png_ptr);
        /* free pointers before returning.  Make sure you clean up
           anything else you've done. */
        free(png_ptr);
        free(info_ptr);
        fclose(fp);
        return;
    }

Then, you will need to call png_info_init() and png_write_init().
These functions make sure all the fields are initialized to useful
values, and, in the case of png_write_init(), allocate any memory
needed for internal uses.  Do png_info_init() first, so if
png_write_init() longjmps, you know info_ptr is valid, so you
don't free random memory pointers, which would be bad.

    png_info_init(info_ptr);
    png_write_init(png_ptr);

Now you need to set up the input code.  The default for libpng is to
use the C function fwrite().  If you use this, you will need to pass a
valid FILE * in the function png_init_io().  Be sure that the file is
opened in binary mode.  Again, if you wish to handle writing data in
another way, see the discussion on libpng I/O handling in the Customizing
Libpng section below.

    png_init_io(png_ptr, fp);

You now have the option of modifying how the compression library
will run.  The following functions are mainly for testing, but
may be useful in certain special cases, like if you need to
write png files extremely fast and are willing to give up some
compression, or if you want to get the maximum possible compression
at the expense of slower writing.  If you have no special needs
in this area, let the library do what it wants, as it has been
carefully tuned to deliver the best speed/compression ratio.
See the compression library for more details.
    
    /* turn on or off filtering (1 or 0) */
    png_set_filtering(png_ptr, 1);

    /* compression level (0 - none, 6 - default, 9 - maximum) */
    png_set_compression_level(png_ptr, Z_DEFAULT_COMPRESSION);
    png_set_compression_mem_level(png_ptr, 8);
    png_set_compression_strategy(png_ptr, Z_DEFAULT_STRATEGY);
    png_set_compression_window_bits(png_ptr, 15);
    png_set_compression_method(png_ptr, 8);

You now need to fill in the png_info structure with all the data you
wish to write before the actual image.  Note that the only thing you
are allowed to write after the image is the text chunks and the time
chunk (as of PNG Specification 0.92, anyway).  See png_write_end() and
the latest PNG specification for more information on that.  If you
wish to write them before the image, fill them in now.  If you want to
wait until after the data, don't fill them until png_write_end().  For
all the fields in png_info, see png.h.  For explanations of what the
fields contain, see the PNG specification.

Some of the more important parts of the png_info are:

    width          - holds the width of the file
    height         - holds the height of the file
    bit_depth      - holds the bit depth of one of the image channels
    color_type     - describes the channels and what they mean
                     see the PNG_COLOR_TYPE_ defines for more information
    interlace_type - currently 0 for none, 1 for interlaced
    valid          - this describes which optional chunks to write to the
                     file.  Note that if you are writing a
                     PNG_COLOR_TYPE_PALETTE file, the PLTE chunk is not
                     optional, but must still be marked for writing.  To
                     mark chunks for writing, OR valid with the 
                     appropriate PNG_INFO_<chunk name> define.
    palette        - the palette for the file
    num_palette    - number of entries in the palette
    gamma          - the gamma the file is written at
    sig_bit        - the number of significant bits for the gray, red, 
                     green, and blue channels, whichever are appropriate
                     for the given color type.
    trans_values   - transparent pixel for non-paletted images
    trans          - array of transparent entries for paletted images
    num_trans      - number of transparent entries
    hist           - histogram of palette
    text           - text comments in the file.
    num_text       - number of comments

A quick word about text and num_text.  text is an array of png_text
structures.  num_text is the number of valid structures in the array.
If you want, you can use max_text to hold the size of the array, but
libpng ignores it for writing (it does use it for reading).  Each
png_text structure holds a keyword-text value, and a compression type.
The compression types have the same valid numbers as the compression
types of the image data.  Currently, the only valid number is zero.
However, you can store text either compressed or uncompressed, unlike
images which always have to be compressed.  So if you don't want the
text compressed, set the compression type to -1.  Until text gets
arount 1000 bytes, it is not worth compressing it.

The keyword-text pairs work like this.  Keywords should be short
simple descriptions of what the comment is about.  Some typical
keywords are found in the PNG specification, as is some recomendations
on keywords.  You can repeat keywords in a file.  You can even write
some text before the image and some after.  For example, you may want
to put a description of the image before the image, but leave the
disclaimer until after, so viewers working over modem connections
don't have to wait for the disclaimer to go over the modem before
they start seeing the image.  Finally, keywords should be full
words, not abbreviations.  Keywords can not contain NUL characters,
and should not contain control characters.  Text in general should
not contain control characters.  The keyword must be present, but
you can leave off the text string on non-compressed pairs.
Compressed pairs must have a text string, as only the text string
is compressed anyway, so the compression would be meaningless.

PNG supports modification time via the png_time structure.  Two
conversion routines are proved, png_convert_from_time_t() for
time_t and png_convert_from_struct_tm() for struct tm.  The
time_t routine uses gmtime().  You don't have to use either of
these, but if you wish to fill in the png_time structure directly,
you should provide the time in universal time (GMT) if possible
instead of your local time.  Note that the year number is the full
year (ie 1996, rather than 96).

It is possible to have libpng flush any pending output, either manually,
or automatically after a certain number of lines have been written.  To
flush the output stream a single time call:

    png_write_flush(png_ptr);

and to have libpng flush the output stream periodically after a certain
number of scanlines have been written, call:

    png_set_flush(png_ptr, nrows);

Note that the distance between rows is from the last time png_write_flush
was called, or the first row of the image if it has never been called.
So if you write 50 lines, and then png_set_flush 25, it will flush the
output on the next scanline, and on line 75, unless png_write_flush is
called earlier.  If nrows is too small (less than about 10 lines) the
image compression may decrease dramatically (although this may be
acceptable for real-time applications).  Infrequent flushing will only
degrade the compression performance by a few percent over images that
do not use flushing.

You are now ready to write all the file information up to the actual
image data.  You do this with a call to png_write_info().

    png_write_info(png_ptr, info_ptr);

After you've read the file information, you can set up the library to
handle any special transformations of the image data.  The various
ways to transform the data will be described in the order that they
should occur.  This is important, as some of these change the color
type and/or bit depth of the data, and some others only work on
certain color types and bit depths.  Even though each transformation
checks to see if it has data that it can do somthing with, you should
make sure to only enable a transformation if it will be valid for the
data.  For example, don't swap red and blue on grayscale data.

PNG files store rgb pixels packed into 3 bytes.  This code tells
the library to use 4 bytes per pixel

    png_set_filler(png_ptr, 0, PNG_FILLER_BEFORE);

where the 0 is not used for writing, and the location is either
PNG_FILLER_BEFORE or PNG_FILLER_AFTER, depending upon whether you
want the filler before the rgb or after.

PNG files pack pixels of bit depths 1, 2, and 4 into bytes as small as
they can, resulting in, for example, 8 pixels per byte for 1 bit files.
If the data is supplied at 1 pixel per byte, use this code, which will
correctly pack the values:

    png_set_packing(png_ptr);

PNG files reduce possible bit depths to 1, 2, 4, 8, and 16.  If your
data is of another bit depth, but is packed into the bytes correctly,
this will scale the values to appear to be the correct bit depth.
Make sure you write a sBIT chunk when you do this, so others, if
they want, can reduce the values down to their true depth.
    
    /* Do this before png_write_info() */
    info_ptr->valid |= PNG_INFO_sBIT;

    /* Note that you can cheat and set all the values of
       sig_bit to true_bit_depth if you want */
    if (info_ptr->color_type & PNG_COLOR_MASK_COLOR)
    {
        info_ptr->sig_bit.red = true_bit_depth;
        info_ptr->sig_bit.green = true_bit_depth;
        info_ptr->sig_bit.blue = true_bit_depth;
    }
    else
    {
        info_ptr->sig_bit.gray = true_bit_depth;
    }

    if (info_ptr->color_type & PNG_COLOR_MASK_ALPHA)
    {
        info_ptr->sig_bit.alpha = true_bit_depth;
    }

    png_set_shift(png_ptr, &(info_ptr->sig_bit));

PNG files store 16 bit pixels in network byte order (big-endian,
ie. most significant bits first).  This code would be used if they are
supplied the other way (little-endian, ie. least significant bits
first, eg. the way PCs store them):

    png_set_swap(png_ptr);

PNG files store 3 color pixels in red, green, blue order.  This code
would be used if they are supplied as blue, green, red:

    png_set_bgr(png_ptr);

PNG files describe monochrome as black being zero and white being
one. This code would be used if the pixels are supplied with this reversed
(black being one and white being zero):

    png_set_invert(png_ptr);

That's it for the transformations.  Now you can write the image data.
The simplest way to do this is in one function call.  If have the
whole image in memory, you can just call png_write_image() and libpng
will write the image.  You will need to pass in an array of pointers to
each row.  This function automatically handles interlacing, so you don't
need to call png_set_interlace_handling() or call this function multiple
times, or any of that other stuff necessary with png_write_rows().

    png_write_image(png_ptr, row_pointers);

where row_pointers is:

    png_bytef *row_pointers[height];

You can point to void or char or whatever you use for pixels.

If you can't want to write the whole image at once, you can
use png_write_rows() instead.  If the file is not interlaced,
this is simple:

    png_write_rows(png_ptr, row_pointers, number_of_rows);

row_pointers is the same as in the png_write_image() call.

If you are just writing one row at a time, you can do this with
row_pointers:

    png_bytep row_pointers = row;

    png_write_rows(png_ptr, &row_pointers, 1);

When the file is interlaced, things can get a good deal more
complicated.  The only currently (as of 1/96 -- PNG Specification
version 0.92) defined interlacing scheme for PNG files is a
compilcated interlace scheme, known as Adam7, that breaks down an
image into seven smaller images of varying size.  libpng will build
these images for you, or you can do them yourself.  If you want to
build them yourself, see the PNG specification for details of which
pixels to write when.

If you don't want libpng to handle the interlacing details, just
call png_write_rows() the correct number of times to write all
seven sub-images.

If you want libpng to build the sub-images, call this before you start
writing any rows:

    number_passes = png_set_interlace_handling(png_ptr);

This will return the number of passes needed.  Currently, this
is seven, but may change if another interlace type is added.

Then write the image number_passes times.

    png_write_rows(png_ptr, row_pointers, number_of_rows);

As some of these rows are not used, and thus return immediately,
you may want to read about interlacing in the PNG specification,
and only update the rows that are actually used.

After you are finished writing the image, you should finish writing
the file.  If you are interested in writing comments or time, you should
pass the an appropriately filled png_info pointer.  If you
are not interested, you can pass NULL.  Be careful that you don't
write the same text or time chunks here as you did in png_write_info().

    png_write_end(png_ptr, info_ptr);

When you are done, you can free all memory used by libpng like this:

   png_write_destroy(png_ptr);

Any data you allocated for png_info, you must free yourself.

After that, you can discard the structures, or reuse them another
read or write.  For a more compact example of writing a PNG image,
see the file example.c.


V. Modifying/Customizing libpng:

There are two issues here.  The first is changing how libpng does
standard things like memory allocation, input/output, and error handling.
The second deals with more complicated things like adding new chunks,
adding new transformations, and generally changing how libpng works.

All of the memory allocation, input/output, and error handling in
libpng goes through callbacks which are user setable.  The default
routines are in pngmem.c, pngio.c, and pngerror.c respectively.  To
change these functions, call the approprate _fn function.

Memory allocation is done through the functions png_large_malloc(),
png_malloc(), png_realloc(), png_large_free(), and png_free().
These currently just call the standard C functions.  The large
functions must handle exactly 64K, but they don't have to handle
more then that.  If your pointers can't access more then 64K at a
time, you will want to set MAXSEG_64K in zlib.h.  Since it is unlikely
that the method of handling memory allocation on a platform will
change between applications, these functions must be modified in the
library at compile time.

Input/Output in libpng is done throught png_read() and png_write(), which
currently just call fread() and fwrite().  The FILE * is stored in
png_struct, and is initialized via png_init_io().  If you wish to change
the method of I/O, the library supplies callbacks that you can set through
the function png_set_read_fn() and png_set_write_fn() at run time.  These
functions also provide a void pointer that can be retrieved via the function
png_get_io_ptr().  For example:

    png_set_read_fn(png_structp png_ptr, voidp io_ptr,
        png_rw_ptr read_data_fn)

    png_set_write_fn(png_structp png_ptr, voidp io_ptr,
        png_rw_ptr write_data_fn, png_flush_ptr output_flush_fn);

    voidp io_ptr = png_get_io_ptr(png_ptr);

The replacement I/O functions should have prototypes as follows:

    void user_read_data(png_structp png_ptr, png_bytep data,
        png_uint_32 length);
    void user_write_data(png_structp png_ptr, png_bytep data,
        png_uint_32 length);
    void user_flush_data(png_structp png_ptr);

Supplying NULL for the read, write, or flush functions sets them back
to using the default C stream functions.  It is an error to read from
a write stream, and vice versa.

Error handling in libpng is done through png_error() and png_warning().
Errors handled through png_error() are fatal, meaning that png_error()
should never return to it's caller.  Currently, this is handled via
setjmp() and longjmp(), but you could change this to do things like
exit() if you should wish.  On non-fatal errors, png_warning() is called
to print a warning message, and then control returns to the calling code.
By default png_error() and png_warning() print a message on stderr.  If
you wish to change the behavior of the error functions, you will need to
set up your own message callbacks.  You do this like the I/O callbacks above.

    png_set_message_fn(png_structp png_ptr, png_voidp msg_ptr,
        png_msg_ptr error_fn, png_msg_ptr warning_fn);

    png_voidp msg_ptr = png_get_msg_ptr(png_ptr);

The replacement message functions should have parameters as follows:

    void user_error_fn(png_struct png_ptr, png_const_charp error_msg);
    void user_warning_fn(png_struct png_ptr, png_const_charp warning_msg);

The motivation behind using setjmp() and longjmp() is the C++ throw and
catch exception handling methods.  This makes the code much easier to write,
as there is no need to check every return code of every function call.
However, there are some uncertainties about the status of local variables
after a longjmp, so the user may want to be careful about doing anything after
setjmp returns non zero besides returning itself.  Consult your compiler
documentation for more details.

If you need to read or write custom chunks, you will need to get deeper
into the libpng code.  First, read the PNG specification, and have
a first level of understanding of how it works.  Pay particular
attention to the sections that describe chunk names, and look
at how other chunks were designed, so you can do things similarly.
Second, check out the sections of libpng that read and write chunks.
Try to find a chunk that is similar to yours and copy off of it.
More details can be found in the comments inside the code.

If you wish to write your own transformation for the data, look
through the part of the code that does the transformations, and check
out some of the simpler ones to get an idea of how they work.  Try to
find a similar transformation to the one you want to add and copy off
of it.  More details can be found in the comments inside the code
itself.

Configuring for 16 bit platforms:

You may need to change the png_large_malloc() and
png_large_free() routines in pngmem.c, as these are requred
to allocate 64K.  Also, you will want to look into zconf.h to tell
zlib (and thus libpng) that it cannot allocate more then 64K at a
time.  Even if you can, the memory won't be accessable.  So limit zlib
and libpng to 64K by defining MAXSEG_64K.

Configuring for DOS:

For DOS users which only have access to the lower 640K, you will
have to limit zlib's memory usage via a png_set_compression_mem_level()
call.  See zlib.h or zconf.h in the zlib library for more information.

Configuring for Medium Model:

Libpng's support for medium model has been tested on most of the popular
complers.  Make sure MAXSEG_64K gets defined, USE_FAR_KEYWORD gets
defined, and FAR gets defined to far in pngconf.h, and you should be
all set.  Everything in the library (except for zlib's structure) is
expecting far data.  You must use the typedefs with the p or pp on
the end for pointers (or at least look at them and be careful).  Make
note that the row's of data are defined as png_bytepp which is a
unsigned char far * far *.

Configuring for gui/windowing platforms:

You will need to change the error message display in png_error() and
png_warning() to display a message instead of fprinting it to stderr.
You may want to write a single function to do this and call it something
like png_message().  On some compliers, you may have to change the
memory allocators (png_malloc, etc.).

Configuring for compiler xxx:

All includes for libpng are in pngconf.h.  If you need to add/change/delete
an include, this is the place to do it.  The includes that are not
needed outside libpng are protected by the PNG_INTERNAL definition,
which is only defined for those routines inside libpng itself.  The
files in libpng proper only include png.h, which includes pngconf.h.

Configuring zlib:

There are special functions to configure the compression.  Perhaps
the most useful one changes the compression level.  The library
normally uses the default compression level, but for maximum
compression (9) or maximum speed (1), you may desire to change the
level.  You do this by calling:

    png_set_compression_mem_level(png_ptr, level);

Another useful one is to reduce the memory level used by the library.
The memory level defaults to 8, but it can be lowered if you are
short on memory (running DOS, for example, where you only have 640K).

    png_set_compression_mem_level(png_ptr, level);

If you want to control whether libpng uses filtering or not, you
can call this function.  I recommend not changing the default unless
you are experimenting with compression ratios.

    png_set_filtering(png_ptr, use_filter);

The other functions are for configuring zlib.  They are not recommended
for normal use and may result in writing an invalid png file.  See
zlib.h for more information on what these mean.

    png_set_compression_strategy(png_ptr, strategy);
    png_set_compression_window_bits(png_ptr, window_bits);
    png_set_compression_method(png_ptr, method);

Except for png_set_filtering(), all of these are just controlling
zlib, so see the zlib documentation (zlib.h and zconf.h) for more
information.

Removing unwanted object code:

There are a bunch of #define's in pngconf.h that control what parts of
libpng are compiled.  All the defines end in _SUPPORT.  If you are
never going to use an ability, you can change the #define to #undef and
save yourself code and data space.  All the reading and writing
specific code are in seperate files, so the linker should only grab
the files it needs.  However, if you want to make sure, or if you
are building a stand alone library, all the reading files start with
pngr and all the writing files start with pngw.  The files that
don't match either (like png.c, pngtrans.c, etc.) are used for
both reading and writing, and always need to be included.  The
progressive reader is in pngpread.c

