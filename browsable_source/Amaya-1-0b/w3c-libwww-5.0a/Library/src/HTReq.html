<HTML>
<HEAD>
  <!-- Changed by: Henrik Frystyk Nielsen, 15-Jul-1996 -->
  <TITLE>W3C Reference Library libwww Request Class</TITLE>
</HEAD>
<BODY>
<H1>
  The Request Class
</H1>
<PRE>
/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/
</PRE>
<P>
Libwww is based on a request/response paradigm and the Request class defines
"<I>an operation to be performed on a URL</I>". The request object is the
main entry point for an application to issue a request to the Library - all
operations on a URL <I>must</I> use a Request object. The request object
is application independent in that both servers and clients use the same
Request class. Examples of requests passed to the Library are a client
application issuing a <B>GET</B> request on a HTTP URL, or a server issuing
a load on a local file URL. The only difference is that the client gets the
input from a user whereas the server gets the input via the network.
<P>
A request object is created with a default set of parameters which are applicable
for many URL requests but the class defines a huge set of methods that an
be used to customize a request for a particular purpose. Example of things
that you can define is natural language, media types, what RFC 822 headers
to use, whether the request should be refreshed from cache etc. Scroll down
and see the set of parameters you can tune.
<P>
A request object is registered in the library by issuing an operation on
a URL - for example <B>PUT</B>, <B>POST</B>, or <B>DELETE</B>. You can find
many higher level "request issuing functions" in the
<A HREF="HTAccess.html">Access module</A> - the methods defined by the Request
class itself are very low level but can of course be used directly if needed.
<P>
Whereas the lifetime of the URL (in form of an anchor) often is very long
(for example as long as the application is running), the lifetime of a request
is limited to the time it takes to service the request. The core does not
automatically delete any request object created by the application - it is
for the application to do. In many cases a request object can be deleted
when any of the <A HREF="HTNet.html#callout">termination callback functions</A>
are called but the application may keep request objects around longer than
that
<P>
The Library can accept an unlimited number of simultaneous requests passed
by the application. One of the main functions of the Library core is to handle
any number of ongoing requests in an intelligent manner by limiting the number
of active request to the fit the available resources as defined by the
application. This is described in more detail in the <A HREF="HTNet.html">HTNet
module</A>.
<P>
This module is implemented by <A HREF="HTReqMan.c">HTReqMan.c</A>, and it
is a part of the <A HREF="http://www.w3.org/pub/WWW/Library/"> W3C Reference
Library</A>.
<PRE>
#ifndef HTREQ_H
#define HTREQ_H

typedef long HTRequestID;
typedef struct _HTRequest HTRequest;

#include "HTEvent.h"
#include "HTList.h"
#include "HTAssoc.h"
#include "HTFormat.h"
#include "HTStream.h"
#include "HTError.h"
#include "HTNet.h"
#include "HTUser.h"
#include "HTResponse.h"
</PRE>
<H2>
  Issuing a Request
</H2>
<P>
This is the "<I>basic request issue method</I>" provided by the Request class.
This is a very low level API as the caller must have set up the request object
before passing it to the Library. You can find many higher level issuing
functions in the <A HREF="HTAccess.html">HTAccess module</A>. If you like,
you can of course use this directly!
<PRE>
extern BOOL HTLoad (HTRequest * request, BOOL recursive);
</PRE>
<H2>
  Killing a Request
</H2>
<P>
This function kills this particular request, see <A HREF="HTNet.html">HTNet
module</A> for a function that kills them all.
<PRE>
extern BOOL HTRequest_kill(HTRequest * request);
</PRE>
<H2>
  Creation and Deletion Methods
</H2>
<P>
The request object is intended to live as long as the request is still active,
but can be deleted as soon as it has terminated, for example in one of the
request termination callback functions as described in the
<A HREF="HTNet.html">Net Manager</A>. Only the anchor object stays around
after the request itself is terminated.
<H3>
  Create new Object
</H3>
<P>
Creates a new request object with a default set of options -- in most cases
it will need some information added which can be done using the methods in
this module, but it will work as is for a simple request.
<PRE>
extern HTRequest * HTRequest_new (void);
</PRE>
<H3>
  Clear a Request Object
</H3>
<P>
Clears all protocol specific information so that the request object can be
used for another request. It should be use with care as application specific
information is <B>not</B> re-initialized. Returns YES if OK, else NO.
<PRE>
extern BOOL HTRequest_clear (HTRequest * me);
</PRE>
<H3>
  Create a duplicate
</H3>
<P>
Creates a new HTRequest object as a duplicate of the src request. Returns
YES if OK, else NO
<PRE>
extern HTRequest * HTRequest_dup (HTRequest * src);
</PRE>
<H4>
  Create a duplicate for Internal use
</H4>
<P>
Creates a new HTRequest object as a duplicate of the src request. The difference
to the HTRequest_dup function is that we don't copy the error_stack and other
information that the application keeps in its copy of the request object.
Otherwise it will be freed multiple times. Returns YES if OK, else NO
<PRE>
extern HTRequest * HTRequest_dupInternal (HTRequest * src);
</PRE>
<H3>
  Delete Object
</H3>
<P>
This function deletes the object and cleans up the memory.
<PRE>
extern void HTRequest_delete (HTRequest * request);
</PRE>
<H2>
  Date and Time Stamp when Request was Issued
</H2>
<P>
The start time when the request was issued may be of value to the cache
validation mechanism as described by the HTTP/1.1 specification. The value
is automatically set when creating the request headers and sending off the
request. The time is a local time.
<PRE>
extern time_t HTRequest_date  (HTRequest * request);
extern BOOL HTRequest_setDate (HTRequest * request, time_t date);
</PRE>
<H2>
  Set the Method for the Request
</H2>
<P>
The Method is the operation to be executed on the requested object. The default
set if the set of operations defined by the HTTP protocol, that is "GET",
"HEAD", "PUT", "POST", "LINK", "UNLINK", and "DELETE" but many of these can
be used in other protocols as well. The important thing is to think of the
requested element as an object on which you want to perform an operation.
Then it is for the specific protocol implementation to try and carry this
operation out. However, not all operations can be implemented (or make sense)
in all protocols.
<P>
Methods are handled by the <A HREF="HTMethod.html">Method Module</A>, and
the default value is "GET".
<PRE>
extern void HTRequest_setMethod (HTRequest *request, HTMethod method);
extern HTMethod HTRequest_method (HTRequest *request);
</PRE>
<H2>
  Priority Management
</H2>
<P>
The request can be assigned an initial priority which then gets inherited
by all HTNet objects and other requests objects created as a result of this
one. You can also assign a separate priority to an indicidual HTNet object
by using the methods in the <A HREF="HTNet.html">Net manager</A>.
<PRE>
extern HTPriority HTRequest_priority (HTRequest * request);
extern BOOL HTRequest_setPriority (HTRequest * request, HTPriority priority);
</PRE>
<H2>
  Binding to a User Profile
</H2>
<P>
Each request is associated with a <A HREF="HTUser.html">User profile</A>
which contains information about the local host name, email address of the
user, news server etc. A request object is created with a default "generic
user" but can be assigned a specific user at any time.
<PRE>
extern BOOL HTRequest_setUserProfile (HTRequest * request, HTUserProfile * up);
extern HTUserProfile * HTRequest_userProfile (HTRequest * request);
</PRE>
<H2>
  Binding to a Net Object
</H2>
<P>
If a request is actually going on the net then the <A HREF="HTNet.html">Net
Manager</A> is contacted to handle the request. The Net manager creates a
HTNEt object and links it to the Request object. You can get to the HTNet
object using the following functions.
<PRE>
extern HTNet * HTRequest_net (HTRequest * request);
extern BOOL HTRequest_setNet (HTRequest * request, HTNet * net);
</PRE>
<H2>
  Binding to a Response Object
</H2>
<P>
If a request is actually going on the net and we are getting a response back
then we also create a HTResponse object and bind it to the request object.
Once we know what to do with the response, we may transfer the information
to the anchor object.
<PRE>
extern HTResponse * HTRequest_response (HTRequest * request);
extern BOOL HTRequest_setResponse (HTRequest * request, HTResponse * response);
</PRE>
<H2>
  <A NAME="Error">Error Object</A>
</H2>
<P>
Errors are like almost anything kept in lists and a error list can be associated
with a request using the following functions. In order to make life easier,
there are also some easy mapping functions to the
<A HREF="HTError.html">HTError object</A>, so that you can add an error directly
to a request object.
<PRE>
extern HTList * HTRequest_error (HTRequest * request);
extern void HTRequest_setError	(HTRequest * request, HTList * list);
</PRE>
<P>
These are the cover functions that go directly to the
<A HREF="HTError.html">Error Object</A>
<PRE>
extern BOOL HTRequest_addError (HTRequest * 	request,
				HTSeverity	severity,
				BOOL		ignore,
				int		element,
				void *		par,
				unsigned int	length,
				char *		where);

extern BOOL HTRequest_addSystemError (HTRequest * 	request,
				      HTSeverity 	severity,
				      int		errornumber,
				      BOOL		ignore,
				      char *		syscall);
</PRE>
<H2>
  Max number of Retrys for a Down Load
</H2>
<P>
Automatic reload can happen in two situations:
<UL>
  <LI>
    The server sends a redirection response
  <LI>
    The document has expired
</UL>
<P>
In order to avoid the Library going into an infinite loop, it is necessary
to keep track of the number of automatic reloads. Loops can occur if the
server has a reload to the same document or if the server sends back a Expires
header which has already expired. The default maximum number of automatic
reloads is 6.
<PRE>
extern BOOL HTRequest_setMaxRetry (int newmax);
extern int  HTRequest_maxRetry (void);

extern int HTRequest_retrys (HTRequest * request);
extern BOOL HTRequest_doRetry (HTRequest *request);
extern BOOL HTRequest_addRetry (HTRequest * request);
</PRE>
<H2>
  Set Max Forwards for TRACE methods
</H2>
<P>
The <CODE>TRACE</CODE> method is used to invoke a remote, application-layer
loop-back of the request message. The final recipient of the request SHOULD
reflect the message received back to the client as the entity-body of a 200
(OK) response. The final recipient is either the origin server or the first
proxy or gateway to receive a Max-Forwards value of zero (0) in the request.
A <CODE>TRACE</CODE> request <I>MUST NOT</I> include an entity.
<PRE>extern BOOL HTRequest_setMaxForwards (HTRequest * request, int maxforwards);
extern int HTRequest_maxForwards (HTRequest * request);
</PRE>
<H2>
  Preemptive or Non-preemptive Access
</H2>
<P>
A access scheme is defined with a default for using either preemptive (blocking
I/O) or non-premitve (non-blocking I/O). This is basically a result of the
implementation of the protocol module itself. However, if non-blocking I/O
is the default then some times it is nice to be able to set the mode to blocking
instead. For example when loading the first document (the home page) then
blocking can be used instead of non-blocking.
<PRE>
extern void HTRequest_setPreemptive (HTRequest *request, BOOL mode);
extern BOOL HTRequest_preemptive (HTRequest *request);
</PRE>
<H2>
  Content Negotiation
</H2>
<P>
When accessing the local file system, the Library is capable of performing
content negotioation as described by the HTTP protocol. This is mainly for
server applications, but some client applications might also want to use
content negotiation when accessing the local file system. This method enables
or disables content negotiation - the default value is <EM>ON</EM>.
<PRE>
extern void HTRequest_setNegotiation (HTRequest *request, BOOL mode);
extern BOOL HTRequest_negotiation (HTRequest *request);
</PRE>
<H2>
  Handling Metainformation (RFC822 Headers)
</H2>
<P>
The Library supports a large set of headers that can be sent along with a
request (or a response for that matter). All headers can be either disabled
or enabled using bit flags that are defined in the following.
<H3>
  <A NAME="gnhd">General HTTP Header Mask</A>
</H3>
<P>
There are a few header fields which have general applicability for both request
and response mesages, but which do not apply to the communication parties
or theentity being transferred. This mask enables and disables these headers.
If the bit is not turned on they are not sent. All headers are optional and
the default value is <EM>NO GENERAL HEADERS</EM>
<PRE>
typedef enum _HTGnHd {
    HT_G_CC             = 0x1,
    HT_G_CONNECTION	= 0x2,
    HT_G_DATE		= 0x4,
    HT_G_PRAGMA_NO_CACHE= 0x8,
    HT_G_FORWARDED	= 0x10,
    HT_G_MESSAGE_ID	= 0x20,
    HT_G_MIME		= 0x40
} HTGnHd;

#define DEFAULT_GENERAL_HEADERS		HT_G_CONNECTION + HT_G_CC

extern void HTRequest_setGnHd (HTRequest *request, HTGnHd gnhd);
extern void HTRequest_addGnHd (HTRequest *request, HTGnHd gnhd);
extern HTGnHd HTRequest_gnHd (HTRequest *request);
</PRE>
<H3>
  <A NAME="rqhd">Request Headers</A>
</H3>
<P>
The request header fields allow the client to pass additional information
about the request (and about the client itself) to the server. All headers
are optional but the default value is all request headers if present
<EM>except</EM> <CODE>From</CODE> and <CODE>Pragma</CODE>.
<PRE>
typedef enum _HTRqHd {
    HT_C_ACCEPT_TYPE	= 0x1,
    HT_C_ACCEPT_CHAR	= 0x2,
    HT_C_ACCEPT_ENC	= 0x4,
    HT_C_ACCEPT_LAN	= 0x8,
    HT_C_AUTH		= 0x10,             /* Includes proxy authentication */
    HT_C_FROM		= 0x20,
    HT_C_HOST		= 0x40,
    HT_C_IMS		= 0x80,
    HT_C_IF_MATCH	= 0x100,
    HT_C_IF_NONE_MATCH	= 0x200,
    HT_C_IF_RANGE	= 0x400,
    HT_C_IF_UNMOD_SINCE	= 0x800,
    HT_C_MAX_FORWARDS	= 0x1000,
    HT_C_RANGE		= 0x2000,
    HT_C_REFERER	= 0x4000,
    HT_C_USER_AGENT	= 0x8000
} HTRqHd;

#define DEFAULT_REQUEST_HEADERS	\
	HT_C_ACCEPT_TYPE + HT_C_ACCEPT_CHAR + \
	HT_C_ACCEPT_ENC + HT_C_ACCEPT_LAN + HT_C_AUTH + \
	HT_C_HOST + HT_C_REFERER + HT_C_USER_AGENT

extern void HTRequest_setRqHd (HTRequest *request, HTRqHd rqhd);
extern void HTRequest_addRqHd (HTRequest *request, HTRqHd rqhd);
extern HTRqHd HTRequest_rqHd (HTRequest *request);
</PRE>
<H3>
  <A NAME="rshd">Response Headers</A>
</H3>
<P>
The response header fields allow the server to pass additional information
about the response (and about the server itself) to the client. All headers
are optional.
<PRE>
typedef enum _HTRsHd {
    HT_S_AGE		= 0x1,
    HT_S_LOCATION   	= 0x2,
    HT_S_PROXY_AUTH 	= 0x4,
    HT_S_PUBLIC    	= 0x8,
    HT_S_RETRY_AFTER	= 0x10,
    HT_S_SERVER		= 0x20,
    HT_S_VARY		= 0x40,
    HT_S_WARNING	= 0x80,
    HT_S_WWW_AUTH	= 0x100
} HTRsHd;

#define DEFAULT_RESPONSE_HEADERS HT_S_SERVER

extern void HTRequest_setRsHd (HTRequest * request, HTRsHd rshd);
extern void HTRequest_addRsHd (HTRequest * request, HTRsHd rshd);
extern HTRsHd HTRequest_rsHd (HTRequest * request);
</PRE>
<H3>
  <A NAME="enhd">Entity Header Mask</A>
</H3>
<P>
The entity headers contain information about the object sent in the HTTP
transaction. See the <A HREF="HTAnchor.html">Anchor module</A>, for the storage
of entity headers. This flag defines which headers are to be sent in a request
together with an entity body. All headers are optional but the default value
is <EM>ALL ENTITY HEADERS IF PRESENT</EM>
<PRE>
typedef enum _HTEnHd {
    HT_E_ALLOW			= 0x1,
    HT_E_CONTENT_BASE		= 0x2,
    HT_E_CONTENT_ENCODING	= 0x4,
    HT_E_CONTENT_LANGUAGE	= 0x8,
    HT_E_CONTENT_LENGTH		= 0x10,
    HT_E_CONTENT_LOCATION	= 0x20,
    HT_E_CONTENT_MD5		= 0x40,
    HT_E_CONTENT_RANGE		= 0x80,
    HT_E_CTE			= 0x100,	/* Content-Transfer-Encoding */
    HT_E_CONTENT_TYPE		= 0x200,
    HT_E_DERIVED_FROM		= 0x400,
    HT_E_ETAG			= 0x800,
    HT_E_EXPIRES		= 0x1000,
    HT_E_LAST_MODIFIED		= 0x2000,
    HT_E_LINK			= 0x4000,
    HT_E_TITLE			= 0x8000,
    HT_E_URI			= 0x10000,
    HT_E_VERSION		= 0x20000
} HTEnHd;

#define DEFAULT_ENTITY_HEADERS		0xFFFF			      /* all */

extern void HTRequest_setEnHd (HTRequest *request, HTEnHd enhd);
extern void HTRequest_addEnHd (HTRequest *request, HTEnHd enhd);
extern HTEnHd HTRequest_enHd (HTRequest *request);
</PRE>
<H2>
  Local MIME header Parsers
</H2>
<P>
MIMEParsers get their own type which is optimized for static and regex parser
strings.
<PRE>
typedef struct _HTMIMEParseSet HTMIMEParseSet;
extern void HTRequest_setMIMEParseSet (HTRequest *request, 
				       HTMIMEParseSet * parseSet, BOOL local);
extern HTMIMEParseSet * HTRequest_MIMEParseSet (HTRequest *request,
					      BOOL * pLocal);
</PRE>
<H2>
  <A NAME="Accept">Accept Headers</A>
</H2>
<P>
The Accept family of headers is an important part of HTTP handling the format
negotiation. The Library supports both a global set of accept headers that
are used in <EM>all</EM> HTTP requests and a local set of accept headers
that are used in specific requests only. The global ones are defined in the
<A HREF="HTFormat.html">Format Manager</A>.
<P>
Each request can have its local set of accept headers that either are added
to the global set or replaces the global set of accept headers. Non of the
headers <EM>have</EM> to be set. If the global set is sufficient for all
requests then this us perfectly fine. If the parameter "override" is set
then only local accept headers are used, else <EM>both</EM> local and global
headers are used.
<H3>
  Content Types
</H3>
<P>
The <EM>local</EM> list of specific conversions which the format manager
can do in order to fulfill the request. It typically points to a list set
up on initialisation time for example by <A HREF="HTInit.html">HTInit()</A>.
There is also a <A HREF="HTFormat.html#z17"><EM>global</EM></A> list of
conversions which contains a generic set of possible conversions.
<PRE>
extern void HTRequest_setConversion (HTRequest *request, HTList *type, BOOL override);
extern HTList * HTRequest_conversion (HTRequest *request);
</PRE>
<H3>
  Content Encodings
</H3>
<P>
The list of encodings acceptable in the output stream.
<PRE>
extern void HTRequest_setEncoding (HTRequest *request, HTList *enc, BOOL override);
extern HTList * HTRequest_encoding (HTRequest *request);
</PRE>
<H3>
  Content Transfer Encodings
</H3>
<P>
The list of transfer encodings acceptable in the output stream.
<PRE>
extern void HTRequest_setTransfer (HTRequest *request, HTList *cte, BOOL override);
extern HTList * HTRequest_transfer (HTRequest *request);
</PRE>
<H3>
  Content Languages
</H3>
<P>
The list of (human) language values acceptable in the response. The default
is all languages.
<PRE>
extern void HTRequest_setLanguage (HTRequest *request, HTList *lang, BOOL override);
extern HTList * HTRequest_language (HTRequest *request);
</PRE>
<H3>
  Content Charsets
</H3>
<P>
The list of charsets accepted by the application
<PRE>
extern void HTRequest_setCharset (HTRequest *request, HTList *charset, BOOL override);
extern HTList * HTRequest_charset (HTRequest *request);
</PRE>
<H2>
  HTTP Cache Validation and Cache Control
</H2>
<P>
The Library has two concepts of caching: in memory and on file. When loading
a document, this flag can be set in order to define who can give a response
to the request. The mempory buffer is considered to be equivalent to a history
buffer. That is, it doesn't not follow the same expiration mechanism that
is characteristic for a persistent file cache.
<P>
You can also set the cache to run in disconnected mode - see the
<A HREF="HTCache.html">Cache manager</A> for more details on how to do this.
<PRE>
typedef enum _HTReload {
    HT_CACHE_OK	            = 0x0,	        /* Use any version available */
    HT_CACHE_FLUSH_MEM	    = 0x1,	/* Reload from file cache or network */
    HT_CACHE_VALIDATE	    = 0x2,	             /* Validate cache entry */
    HT_CACHE_END_VALIDATE   = 0x4,                  /* End to end validation */
    HT_CACHE_RANGE_VALIDATE = 0x8,
    HT_CACHE_FLUSH	    = 0x10                      /* Force full reload */
} HTReload;

extern void HTRequest_setReloadMode (HTRequest *request, HTReload mode);
extern HTReload HTRequest_reloadMode (HTRequest *request);
</PRE>
<H3>
  HTTP Cache Control Directives
</H3>
<P>
The cache control directives are all part of the cache control header and
control the behavior of any intermediate cache between the user agent and
the origin server. This association list is a list of the connection control
directives that are to be sent as part of the <CODE>Cache-Control</CODE>
header.
<PRE>
extern BOOL HTRequest_addCacheControl        (HTRequest * request,
                                              char * token, char *value);
extern BOOL HTRequest_deleteCacheControlAll  (HTRequest * request);
extern HTAssocList * HTRequest_cacheControl  (HTRequest * request);
</PRE>
<H3>
  Partial Requests and Range Retrievals
</H3>
<P>
Libwww can issue range requests in case we have already obtained a part of
the entity body. Since all HTTP entities are represented in HTTP messages
as sequences of bytes, the concept of a byte range is meaningful for any
HTTP entity. (However, not all clients and servers need to support byte-range
operations.) Byte range specifications in HTTP apply to the sequence of bytes
in the entity-body (not necessarily the same as the message-body). A byte
range operation may specify a single range of bytes, or a set of ranges within
a single entity.
<PRE>
extern BOOL HTRequest_addRange       (HTRequest * request,
                                      char * unit, char * range);
extern BOOL HTRequest_deleteRangeAll (HTRequest * request);
extern HTAssocList * HTRequest_range (HTRequest * request);
</PRE>
<H2>
  HTTP Connection Control Request Directives
</H2>
<P>
The connection control directives are all part of the connection header and
control the behavior of this connection. This association list is a list
of the connection control directives that are to be sent as part of the
<CODE>Connection</CODE> header.
<PRE>
extern BOOL HTRequest_addConnection        (HTRequest * request,
                                            char * token, char * value);
extern BOOL HTRequest_deleteConnection     (HTRequest * request);
extern HTAssocList * HTRequest_connection  (HTRequest * request);
</PRE>
<H2>
  <A NAME="Access">HTTP Access Authentication Credentials</A>
</H2>
<P>
When a access denied response is returned to the Library, for example from
a remote HTTP server, this code is passed back to the application. The
application can then decide whether a new request should be established or
not. These two methods return the authentication information required to
issue a new request, that is the new anchor and any list of keywords associated
with this anchor.
<PRE>
extern BOOL HTRequest_addCredentials       (HTRequest * request,
                                            char * token, char * value);
extern BOOL HTRequest_deleteCredentialsAll (HTRequest * request);
extern HTAssocList * HTRequest_credentials (HTRequest * request);
</PRE>
<H3>
  Realms
</H3>
<PRE>
extern BOOL HTRequest_setRealm (HTRequest * request, char * realm);
extern const char * HTRequest_realm (HTRequest * request);
</PRE>
<H2>
  HTTP Extensions (PEP)
</H2>
<P>
HTTP can be extended in several ways but traditionally it has been by using
new headers. Here we present a new idea which provides a framework for describing
extensions and their scope. This is only an idea an may be modified later!
The implementation of the extensions can be found in the
<A HREF="HTPEP.html">PEP module</A>
<H3>
  Protocol
</H3>
<P>
This association list is a list of the extension directives that are to be
sent as part of the request.
<PRE>
extern BOOL HTRequest_addProtocol       (HTRequest * request,
                                         char * token, char * value);
extern BOOL HTRequest_deleteProtocolAll (HTRequest * request);
extern HTAssocList * HTRequest_Protocol (HTRequest * request);
</PRE>
<H3>
  Protocol Info
</H3>
<P>
This association list is a list of the extension directives that are to be
sent as part of the request.
<PRE>
extern BOOL HTRequest_addProtocolInfo       (HTRequest * request,
                                            char * token, char * value);
extern BOOL HTRequest_deleteProtocolInfoAll (HTRequest * request);
extern HTAssocList * HTRequest_ProtocolInfo (HTRequest * request);
</PRE>
<H3>
  Protocol Request
</H3>
<P>
This association list is a list of the extension directives that are to be
sent as part of the request.
<PRE>
extern BOOL HTRequest_addProtocolRequest       (HTRequest * request,
                                               char * token, char * value);
extern BOOL HTRequest_deleteProtocolRequestAll (HTRequest * request);
extern HTAssocList * HTRequest_ProtocolRequest (HTRequest * request);
</PRE>
<H2>
  HTTP Referer Field
</H2>
<P>
If this parameter is set then a `Referer: &lt;parent address&gt; can be generated
in the request to the server, see
<A HREF="http://www.w3.org/pub/WWW/Protocols/">Referer field in a HTTP
Request</A>
<PRE>
extern void HTRequest_setParent (HTRequest *request, HTParentAnchor *parent);
extern HTParentAnchor * HTRequest_parent (HTRequest *request);
</PRE>
<H2>
  Extra Headers
</H2>
<P>
Extra header information can be send along with a request using this variable.
The text is sent as is so it must be preformatted with
<CODE>&lt;CRLF&gt;</CODE> line terminators. This will get changed at some
point so that you can register a header together with a handler in the MIME
parser.
<PRE>
extern void HTRequest_setGenerator (HTRequest *request, HTList *gens, 
				    BOOL override);
extern HTList * HTRequest_generator (HTRequest *request, BOOL *override);
</PRE>
<H2>
  <A NAME="before">BEFORE and AFTER Filters</A>
</H2>
<P>
The request object may have it's own before and after
<A HREF="HTFilter.html">filters</A>. These may override or suplement the
global set in <A HREF="HTNet.html">HTNet</A>. The request object itself handles
the list element, that is this should not be freed bu the caller.
<H3>
  BEFORE Filters
</H3>
<P>
The BEFORE <A HREF="HTFilter.html">filters</A> are called just after the
request has been passed to the Library but before any request is issued over
the network. A BEFORE can infact stop a request completely from being processed.
<H4>
  Add a local BEFORE Filter
</H4>
<P>
You can add a local <I>BEFORE</I> filter for a single request so that the
both the local and global <I>BEFORE</I> filters are called or you can replace
the global filters with a local set. Note that the local set can be NULL.
This can be used to effectively disable all <I>BEFORE</I> filters without
unregistering the global ones.
<PRE>
extern BOOL HTRequest_addBefore (HTRequest * request, HTNetBefore * filter,
				 const char * tmplate, void * param,
                                 HTFilterOrder order, BOOL override);
extern HTList * HTRequest_before (HTRequest * request, BOOL * override);
</PRE>
<H4>
  Delete a Local BEFORE Filter
</H4>
<P>
You can delete a local BEFORE filter explicitly by passing the filter itself
or you can delete all filters which are registered for a certain status code.
<PRE>extern BOOL HTRequest_deleteBefore (HTRequest * request, HTNetBefore * filter);
extern BOOL HTRequest_deleteBeforeAll (HTRequest * request);
</PRE>
<H3>
  AFTER Filters
</H3>
<P>
You can add a local AFTER filter for a single request so that the both the
local and global AFTER filters are called or you can replace the global filters
with a local set. Note that the local set can be NULL. This can be used to
effectively disable all AFTER filters without unregistering the global ones.
<P>
AFTER filters can be registered to handle a certain set of return values
from the protocol modules, for example explicitly to handle redirection,
authentication, etc. You can find all the available codes in the HTNet object
description.
<H4>
  Add a local AFTER Filter
</H4>
<PRE>
extern BOOL HTRequest_addAfter (HTRequest * request, HTNetAfter * filter,
				const char * tmplate, void * param,
                                int status, HTFilterOrder order,
                                BOOL override);
extern HTList * HTRequest_after (HTRequest * request, BOOL * override);
</PRE>
<H4>
  Delete an AFTER Filter
</H4>
<P>
You can delete a local AFTER filter explicitly by passing the filter itself
or you can delete all filters which are registered for a certain status code.
<PRE>
extern BOOL HTRequest_deleteAfter (HTRequest * request, HTNetAfter * filter);
extern BOOL HTRequest_deleteAfterStatus (HTRequest * request, int status);
extern BOOL HTRequest_deleteAfterAll (HTRequest * request);
</PRE>
<H2>
  Sending data to the Network
</H2>
<P>
Multiple Request objects can be connected in order to create a
<A HREF="../User/Architecture/PostWeb.html">PostWeb</A> for sending data
from one location (source) to another (destination). Request objects are
bound together by connecting the output stream of the source with the input
stream of the destination requst. The connection can be done directly so
that the output from the source is exactly what is sent to the destination
or there can be a conversion between the two streams so that we can do
conversions on the fly while copying data. This is in fact the way we use
for building a proxy server.
<P>
The Library supports two ways of posting a data object to a remote destination:
Input comes from a socket descriptor or from memory. In the case where you
want to <EM>copy</EM> a URL, for example from local file system <EM>or</EM>
from a remote HTTP server then you must use the
<A HREF="../User/Architecture/PostWeb.html">PostWeb design</A>. This model
operates by using at least two request objects which gets linked to eachother
as part of the PostWeb model. However, if you are posting from memory, we
only use <EM>one</EM> request object to perform the operation. In order to
do this, the application must register a callback function that can be called
when the <A HREF="HTTP.c">HTTP client module</A> is ready for accepting data.
be included as part of the body and/or as extra metainformation. In the latter
case you need to register a callback function of the following type using
the methods provided in the next section.
<PRE>
typedef int HTPostCallback (HTRequest * request, HTStream * target);

extern void HTRequest_setPostCallback (HTRequest * request, HTPostCallback * cbf);
extern HTPostCallback * HTRequest_postCallback (HTRequest * request);
</PRE>
<P>
The Entity Anchor is either the anchor directly associated with the Request
object or the post anchor associated with the object. The purpose of the
entity anchor is if we are to send data to a remote server then we get the
metainformation using the entity anchor.
<PRE>
extern BOOL HTRequest_setEntityAnchor (HTRequest * request, HTParentAnchor * anchor);
extern HTParentAnchor * HTRequest_entityAnchor (HTRequest * request);
</PRE>
<H3>
  Input Stream
</H3>
<P>
The input stream is to be used to put data <EM>to</EM> the network. Normally
each protocol sets the input stream in order to generate the protocol headers
while making a request.
<PRE>
extern void HTRequest_setInputStream (HTRequest * request, HTStream * input);
extern HTStream *HTRequest_inputStream (HTRequest * request);
</PRE>
<H3>
  Is This Request part of a Post Web?
</H3>
<P>
Check to see if this request object is part of a Post Web.
<PRE>
extern BOOL HTRequest_isPostWeb (HTRequest * request);
</PRE>
<H3>
  Source of a Request
</H3>
<P>
A request may have a source in which is another request object that as output
stream has the input stream of this request object.
<PRE>
extern BOOL HTRequest_setSource (HTRequest * request, HTRequest * source);
extern HTRequest * HTRequest_source (HTRequest * request);
</PRE>
<H2>
  Streams From Network to Application
</H2>
<H3>
  Default Output Stream
</H3>
<P>
The output stream is to be used to put data down to as they come in
<B>from</B> the network and back to the application. The default value is
<CODE>NULL</CODE> which means that the stream goes to the user (display).
<PRE>
extern void HTRequest_setOutputStream (HTRequest *request, HTStream *output);
extern HTStream *HTRequest_outputStream (HTRequest *request);
</PRE>
<H3>
  Has Output Stream been Connected to Channel?
</H3>
<P>
Has output stream been connected to the channel? If not then we must free
it explicitly when deleting the request object
<PRE>extern void HTRequest_setOutputConnected (HTRequest * request, BOOL mode);
extern BOOL HTRequest_outputConnected	 (HTRequest * request);
</PRE>
<P>
The desired format of the output stream. This can be used to get unconverted
data etc. from the library. If <CODE>NULL</CODE>, then
<A HREF="HTFormat.html#FormatTypes">WWW_PRESENT</A> is default value.
<PRE>
extern void HTRequest_setOutputFormat (HTRequest *request, HTFormat format);
extern HTFormat HTRequest_outputFormat (HTRequest *request);
</PRE>
<H3>
  Debug Stream
</H3>
<P>
All object bodies sent from the server with status codes different from
<CODE>200 OK</CODE> will be put down this stream. This can be used for
redirecting body information in status codes different from "200 OK" to for
example a debug window. If the value is NULL (default) then the stream is
not set up.
<PRE>
extern void HTRequest_setDebugStream (HTRequest *request, HTStream *debug);
extern HTStream *HTRequest_debugStream (HTRequest *request);
</PRE>
<P>
The desired format of the error stream. This can be used to get unconverted
data etc. from the library. The default value if <CODE>WWW_HTML</CODE> as
a character based only has one WWW_PRESENT.
<PRE>
extern void HTRequest_setDebugFormat (HTRequest *request, HTFormat format);
extern HTFormat HTRequest_debugFormat (HTRequest *request);
</PRE>
<H2>
  <A NAME="context">Context Swapping</A>
</H2>
<P>
In multi threaded applications it is often required to keep track of the
context of a request so that when the Library returns a result of a request,
it can be put into the context it was in before the request was first passed
to the Library. This call back function allows the application to do this.
<PRE>
typedef int HTRequestCallback (HTRequest * request, void *param);

extern void HTRequest_setCallback (HTRequest *request, HTRequestCallback *cb);
extern HTRequestCallback *HTRequest_callback (HTRequest *request);
</PRE>
<P>
The callback function can be passed an arbitrary pointer (the void part)
which can describe the context of the current request structure. If such
context information is required then it can be set using the following methods:
<PRE>
extern void HTRequest_setContext (HTRequest *request, void *context);
extern void *HTRequest_context (HTRequest *request);
</PRE>
<H2>
  Binding to an Anchor Object
</H2>
<P>
Every request object has an <A HREF="HTAnchor.html">anchor</A> associated
with it. The anchor normally lives until the application terminates but a
request object only lives as long as the request is being serviced. If the
anchor that we have requested is infact a child anchor then we always load
the parent anchor and then after the load jump to the location. A child anchor
is a an anchor which points to a subpart of the document (has a "#" in the
URL).
<PRE>extern void HTRequest_setAnchor (HTRequest *request, HTAnchor *anchor);
extern HTParentAnchor * HTRequest_anchor (HTRequest *request);

extern HTChildAnchor * HTRequest_childAnchor (HTRequest * request);
</PRE>
<H2>
  Should we Issue a full HTTP Request-URI?
</H2>
<P>
In early versions of HTTP, the request sent to the remote server varies whether
we use a proxy or go directly to the origin server. The default value is
<EM>OFF</EM> but we use a full request if we are talking to a proxy server.
<PRE>
extern void HTRequest_setFullURI (HTRequest *request, BOOL mode);
extern BOOL HTRequest_fullURI (HTRequest *request);
</PRE>
<H2>
  Proxy URL
</H2>
<P>
In case we are using a proxy for this requst then we can register it together
with the request object. That way we can find the proxy and look for
authentication information, for example in the
<A HREF="HTAAUtil.html">Authentication filter</A>. The string is freed by
the Request object on deletion.
<PRE>
extern BOOL HTRequest_setProxy    (HTRequest * request, const char * proxy);
extern char * HTRequest_proxy     (HTRequest * request);
extern BOOL HTRequest_deleteProxy (HTRequest * request);
</PRE>
<H2>
  Bytes Read or Written in a Request
</H2>
<P>
This function returns the bytes read in the current request. For a deeper
description of what the current request is, please read the user's guide.
This function can be used in for example the <A HREF="HTAlert.html">HTAlert
module</A> to give the number of bytes read or written in a progress message.
<PRE>
extern long HTRequest_bytesRead (HTRequest * request);
extern long HTRequest_bytesWritten (HTRequest * request);
</PRE>
<H2>
  Internal Request Objects
</H2>
<P>
The library may under certain circumstances create its own Request objects.
These are all handled internal and does not show up on the application side
at all.
<PRE>
extern BOOL HTRequest_setInternal (HTRequest * request, BOOL mode);
extern BOOL HTRequest_internal (HTRequest * request);
</PRE>
<PRE>
#endif /* HTREQ_H */
</PRE>
<P>
  <HR>
<ADDRESS>
  @(#) $Id: HTReq.html,v 1.1.1.1 1996/10/15 13:08:42 cvs Exp $
</ADDRESS>
</BODY></HTML>
